{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to shu's documentation!","text":"<p>shu is an interface to plot data on top of metabolic networks, with emphasis in multi-dimensional data across diferent conditions and distributions.</p> <p>Shu is available as a web application at https://biosustain.github.io/shu or as a native application (see releases).</p> <p>Check out the plotting section for an overview on how to generate and plot data into the map. The File formats section explains the map (with is fully compatible with escher) and data especification.</p> Map Controls Left-click\u00a0&amp; drag to move around the map Scroll wheel to zoom in / out Middle-click a histogram or the legend, then drag to move it Right-click a histogram or the legend, then drag to rotate / zoom Shift Right-click + Shift on a histogram, then drag to scale its\u00a0x-axis + \u2212 + / \u2212 to scale the legend.       Hold Ctrl to scale the Settings window      \u2699        Use the Settings window to change appearance or export the map as JSON / PNG"},{"location":"developers/","title":"For developers","text":"<p>The following instructions are for developers who want to contribute to shu or deploy it.</p>"},{"location":"developers/#build-instructions-from-source","title":"Build instructions from source","text":"<p>To build shu from source, you need to have Rust and <code>cargo</code> installed. Shu uses the nightly toolchain: </p> <pre><code>rustup toolchain install nightly\n</code></pre> <p>and <code>ldd</code> to speed up linking times. See the bevy setup documentation to install it or simply remove the <code>.cargo</code> directory if that is not desired.</p> <p>Then, clone the repository and build the project:</p> <pre><code>git clone https://github.com/biosustain/shu.git\ncd shu\ncargo build\n</code></pre>"},{"location":"developers/#architecture","title":"Architecture","text":"<p>The API documentation can be found at https://docs.rs/shu.</p> <p>Shu follows a Grammar of Graphics design like ggplot or plotnine. See the plotting chapter for the full analogy. The particular implementation is an Entity Component System in bevy:</p> <ul> <li>Each aesthetic is a component (<code>Gsize</code>, <code>Gcolor</code>, etc.) containing its data (see <code>aesthetics.rs</code>). Identifiers are stored in the <code>Aesthetic</code> component.</li> <li>Entities with <code>Aesthetic</code>, other aes components and Geom component (<code>GeomArrow</code>, <code>GeomMetabolite</code>, etc. in <code>geom.rs</code>) are processed and plotted by a system (in <code>aesthetics.rs</code>).</li> <li>The accepted aesthetics for a given geom are made explicit in the queries of the systems.</li> </ul> <p>Data handling lives in <code>data.rs</code> and <code>escher.rs</code>.</p> <p>About the GUI, there are three separate pieces: the Settings window, the histogram interactions and legend. The settings window is handled by bevy_egui (<code>gui.rs</code>). The histogram interactions are non-UI components spawned in <code>aesthetics.rs</code> and handled mostly in <code>gui.rs</code>. Finally, the legend is in its own separate legend module and consists on UI components in a flexbox in a way that it is by default collapse and only the relevant legend appears once its corresponding data is added to the map.</p>"},{"location":"developers/#deployment","title":"Deployment","text":"<p>Binaries for Linux, Mac, Windows and WASM are generated once release tags are pushed to the repository. For instance, a tag for version 26.2.0 would be pushed in the following way:</p> <pre><code>git tag 26.2.0\ngit push origin 26.2.0\n</code></pre> <p>A github action will build and create the binaries.</p>"},{"location":"developers/#native-deployment","title":"Native deployment","text":"<p>To generate binaries locally:</p> <pre><code>git clone https://github.com/biosustain/shu.git\ncd shu\ncargo build --release\n</code></pre> <p>A binary has been generated at <code>target/release/shu</code>. You can copy it to your path or run it directly from there. Alternatively, simply run</p> <pre><code>cargo install --path .\n</code></pre> <p>And cargo will handle the rest.</p>"},{"location":"developers/#wasm-deployment","title":"WASM deployment","text":"<p>If you want to deploy the WASM version locally or for internal use, you can build it yourself using wasm-bindgen:</p> <pre><code># clone the repository if you haven't already\ngit clone https://github.com/biosustain/shu.git\ncd shu\n# build the wasm version\ncargo build --profile wasm-release --target wasm32-unknown-unknown\n# bundle it into the pkg directory\nwasm-bindgen --out-dir pkg --target web ./target/wasm32-unknown-unknown/wasm-release/shu.wasm\n</code></pre> <p>Afterwards, an <code>index.html</code> file can be created in the root directory that contains <code>pkg</code>. See the gh-pages branch for an example of that. A directory containing the <code>inde.html</code>, <code>assets</code> and <code>pkg</code> directories can be deployed to a static page like Github pages or Gitlab pages.</p>"},{"location":"developers/#contributing","title":"Contributing","text":"<p>Contributions are welcome!</p> <ol> <li>Look up similar issues.</li> <li>Write an issue.</li> <li>Fork the repository.</li> </ol> <pre><code># https\ngit clone https://github.com/biosustain/shu.git\n# or ssh\ngit clone git@github.com:biosustain/shu.git\n# add a remote with to your fork\ngit remote add downstream git@github.com:username/shu.git\n</code></pre> <ol> <li>Branch from trunk.</li> </ol> <pre><code>git checkout -b 'feat-incrediblefeature'\n</code></pre> <ol> <li>Write your code and push the commits to you repository (we use semantic commits).</li> </ol> <pre><code>git commit -m 'feat: add incredible feature'\ngit push -u downstream feat-incrediblefeature\n</code></pre> <ol> <li>Submit a Pull Request with your feature/bug fix.</li> <li>Get the Pull Request approved (CI must pass).  </li> </ol> <p>For the CI to pass, you need to run and pass <code>cargo fmt</code> and <code>cargo test</code> before comitting. <code>cargo clippy</code> is not enforced but desirable.</p> <p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as Apache2.0/MIT, without any additional terms or conditions.</p>"},{"location":"file_formats/","title":"File Formats","text":"<p>For a quick start, see the map example (or any escher map at https://escher.github.io/) and the data example.</p>"},{"location":"file_formats/#map","title":"Map","text":"<p>Shu uses the same format as escher for the maps. Maps from escher can be imported using the Map button (web app) or with drag and drop (native app).</p> <p>The only difference is that the histogram position, rotation and scale (which does not exist in escher) can be exported to the map (only native app for now) using the <code>Export</code> drop down on the <code>Settings</code> window. This allows to save a map with the correct manually fixed positions where different data can be plotted for the same or different projects.</p> <p>For the full JSON specification (ending with the extension .json), please refer to the source code represented by the <code>EscherMap</code> struct found at the map source code.</p>"},{"location":"file_formats/#data","title":"Data","text":"<p>The input data that contains the variables to be plotted in the map is a JSON ending withe .metabolism.json extension. The full specification is the following struct (source code at the data source code):</p> <pre><code>pub struct Data {\n    /// Vector of reactions' identifiers\n    reactions: Option&lt;Vec&lt;String&gt;&gt;,\n    // TODO: generalize this for any Data Type and use them (from escher.rs)\n    /// Numeric values to plot as reaction arrow colors.\n    colors: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Numeric values to plot as reaction arrow sizes.\n    sizes: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Numeric values to plot as histogram.\n    y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot as histogram.\n    left_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot on a hovered histogram popup.\n    hover_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot as KDE.\n    kde_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot as KDE.\n    kde_left_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot on a hovered KDE popup.\n    kde_hover_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot as boxpoint.\n    box_y: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Numeric values to plot as boxpoint.\n    box_left_y: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Vector of identifiers for horizontal ordering of the box boxpoints (right).\n    box_variant: Option&lt;Vec&lt;String&gt;&gt;,\n    /// Vector of identifiers for horizontal ordering of the box boxpoints (left).\n    box_left_variant: Option&lt;Vec&lt;String&gt;&gt;,\n    /// Numeric values to plot a column plot (right).\n    column_y: Option&lt;Vec&lt;Number&gt;&gt;,\n    column_ymin: Option&lt;Vec&lt;Number&gt;&gt;,\n    column_ymax: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Numeric values to plot a column plot (left).\n    left_column_y: Option&lt;Vec&lt;Number&gt;&gt;,\n    left_column_ymin: Option&lt;Vec&lt;Number&gt;&gt;,\n    left_column_ymax: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Categorical values to be associated with conditions.\n    conditions: Option&lt;Vec&lt;String&gt;&gt;,\n    /// Categorical values to be associated with conditions.\n    met_conditions: Option&lt;Vec&lt;String&gt;&gt;,\n    /// Vector of metabolites' identifiers\n    metabolites: Option&lt;Vec&lt;String&gt;&gt;,\n    // TODO: generalize this for any Data Type and use them (from escher.rs)\n    /// Numeric values to plot as metabolite circle colors.\n    met_colors: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Numeric values to plot as metabolite circle sizes.\n    met_sizes: Option&lt;Vec&lt;Number&gt;&gt;,\n    /// Numeric values to plot as histogram on hover.\n    met_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n    /// Numeric values to plot as density on hover.\n    kde_met_y: Option&lt;Vec&lt;Vec&lt;Number&gt;&gt;&gt;,\n}\n</code></pre>"},{"location":"gallery/","title":"Gallery","text":"\u00d7 <pre>import pandas as pd\nfrom ggshu import aes, ggmap, geom_arrow\n\ndf = pd.DataFrame({\n    \"reactions\": [\"PFK\", \"ENO\", \"PYK\", \"GAPD\", \"PGI\", \"PGK\", \"PGM\", \"TPI\"],\n    \"flux\": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],\n    \"kcat\": [20, 30, 40, 10, 200, 100, 50, 120]\n})\n\n(\n    ggmap(df, aes(reaction=\"reactions\", size=\"flux\", color=\"kcat\"))\n    + geom_arrow()\n)\n</pre> \u00d7 <pre>import pandas as pd\nfrom ggshu import aes, ggmap, geom_kde, geom_boxpoint\n\n\ndf = pd.DataFrame({\n    \"reactions\": [\"PFK\", \"PFK\", \"PFK\", \"PFK\", \"PFK\", \"TPI\", \"TPI\", \"TPI\", \"TPI\", \"TPI\"],\n    \"flux\": [1.0, 2.0, 2.0, 2.0, 3.0, 5.0, 4.0, 3.0, 3.0, 3.0],\n    \"kcat\": [20, 30, 40, 10, 200, 100, 50, 120, 120, 120]\n})\n\n(\n    ggmap(df, aes(reaction=\"reactions\", y=\"flux\", color=\"kcat\"))\n    # distributions on the left side\n    + geom_kde(side=\"left\")\n    # boxpoint (by default, on the right side)\n    + geom_boxpoint()\n)\n</pre> \u00d7 <pre>import pandas as pd\nfrom ggshu import aes, ggmap, geom_column\n\n\ndf = pd.DataFrame({\n    \"reactions\": [\"MTHFC\", \"MTHFC\", \"FTHFLi\", \"FTHFLi\", \"MTHFD\", \"MTHFD\"],\n    \"conditions\": [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\"],\n    \"flux\": [1.0, 2.0, 3.0, 4.0, 9.0, 5.0],\n    # if ymin/ymax are missing, the error bar in that direction is not plotted\n    \"flux_min\": [None, 1.0, 1.0, 1.0, 4.0, 4.0],\n    \"flux_max\": [2.0, None, 4.0, 4.5, 10.0, None]\n})\n\nplot = (\n    ggmap(df, aes(y=\"flux\", ymax=\"flux_max\", ymin=\"flux_min\", reaction=\"reactions\"))\n    + geom_column()\n)\n# save to JSON\nplot.to_json(\"columnexp\")\n# alternatively, if in a jupyter notebook\n# this must be in one cell\nview = Shu(height=800)\nview.show(offline=True)\n# change the map in another cell\n# cauto map: https://github.com/biosustain/shu_case_studies/blob/master/maps/cauto_map.json\nwith open(\"../../shu_case_studies/maps/cauto_map.json\") as r:\n    cauto_map = json.load(r)\n    view.load_map(cauto_map)\n# display the data\nplot.show(view)\n</pre> \u00d7 <p>Check out the jupyter notebook.</p> \u00d7 <p>Check out the jupyter notebook.</p>"},{"location":"plotting/","title":"Plotting","text":"<p>Drawing from the concepts of the Grammar of Graphics, shu allows to plot data from a variable to different geometrical properties in the map. A variable here could be the concentration of the metabolites in the cell and the geometrical mapping - or geom - could be the size of the metabolite nodes.</p> <p>The grammar of shu is represented in the following figure:</p> <p></p> <p>To arrange the data in the correct format, a python package called ggshu can be used to create the input for shu from a pandas dataframe. It can be installed with <code>pip</code>:</p> <pre><code>python -m pip install ggshu\n</code></pre>"},{"location":"plotting/#simple-reaction-example","title":"Simple reaction example","text":"<p>First, we will use the pandas library to create an example dataframe:</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"reactions\": [\"PFK\", \"ENO\", \"PYK\", \"GAPD\", \"PGI\", \"PGK\", \"PGM\", \"TPI\"],\n                   \"flux\": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],\n                   \"kcat\": [20, 30, 40, 10, 200, 100, 50, 120]})\n</code></pre> <p>Now, let's say we want to plot the flux as the size and colors of the arrows.</p> <pre><code>from ggshu import aes, ggmap, geom_arrow\n\n(\n    ggmap(df, aes(reaction=\"reactions\", size=\"flux\", color=\"kcat\"))\n)\n</code></pre> <p>With this we are saying that the column <code>reactions</code> in the dataframe identifies the reactions in the map, <code>df.flux</code> maps to the size and <code>df.kcat</code> to the color. Now, we only need to specify which geometrical mapping to use; i.e., the size and color of what (histogram, arrow, nodes, etc.).</p> <pre><code>(\n    ggmap(df, aes(reaction=\"reactions\", size=\"flux\", color=\"kcat\"))\n    + geom_arrow()\n)\n</code></pre> <p>Looking at the image at the top of this page, we can see that the arrow aesthetics take the size and color as aesthetics, so we only needed to specificy the <code>geom_arrow()</code>. Finally, we can export the data as file that can be used by shu.</p> <pre><code>(\n    ggmap(df, aes(reaction=\"reactions\", size=\"flux\", color=\"kcat\"))\n    + geom_arrow()\n).to_json(\"flux_kcat\")\n</code></pre> <p>The call to <code>to_json</code> will generate a file called <code>flux_kcat.metabolism.json</code> (which should look like this data example).</p> <p>Now, go to the shu website and upload the file <code>flux_kcat.metabolism.json</code> and see the result by clicking on the. rigth-top corner button \"Data\".</p> <p>Warning</p> <p>If you are using the native application, you can also drag and drop the file into the application or use the import settings dropdown to write the full path manually.</p> <p>The map should look like this:</p> <p></p> <p>Note</p> <p>Try tweaking the \"Settings\" window to achieve the same colors.</p>"},{"location":"plotting/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>Instead of saving the file to JSON and loading it manually into Shu, ggshu can load Shu in a JupyterLab notebook and let you interact with it through Python.</p> <p>Inside a notebook, create the same plot as before:</p> <pre><code>plot = (\n    ggmap(df, aes(reaction=\"reactions\", size=\"flux\", color=\"kcat\"))\n    + geom_arrow()\n)\n</code></pre> <p>Next, load Shu into the notebook. This will download the necessary files under the hood (it may take a few seconds):</p> <pre><code>from ggshu import Shu\n\nshu_view = Shu(height=740)\nshu_view.show()\n</code></pre> <p>To render your plot in the notebook, simply call the <code>show</code> method:</p> <pre><code>plot.show(shu_view)\n</code></pre> <p>The visualization will appear in the cell where you called <code>shu_view.show()</code>.</p> <p>Warning</p> <p>To conserve resources, shu renders lazily: it updates only when you interact with the app. If you don't see any changes, try hovering your cursor over the map!</p>"},{"location":"plotting/#plotting-distributions","title":"Plotting distributions","text":"<p>For the simple example, the shape of the dataframe did not really matter since we had one value for each reaction. However, to plot more variables to distribution geoms, it is important to understand that ggshu uses a dataframe in tidy format.</p> <p>The rows are the observations and the columns are the variables or features. This effectively means that a reaction can appear in more than one row. Let's now plot some distributions.</p> <pre><code># the reactions do not need to be ordered!\ndf = pd.DataFrame({\"reactions\": [\"PFK\", \"PFK\", \"PFK\", \"PFK\", \"PFK\", \"TPI\", \"TPI\", \"TPI\", \"TPI\", \"TPI\"],\n                   \"flux\": [1.0, 2.0, 2.0, 2.0, 3.0, 5.0, 4.0, 3.0, 3.0, 3.0],\n                   \"kcat\": [20, 30, 40, 10, 200, 100, 50, 120, 120, 120]})\n</code></pre> <p>Since we now have distributions, plotting the data as the color would allow only to use the mean or any other summary statistics per reaction. This loses a lot of information. Luckily, we can use an histogram or a density instead!</p> <pre><code>from ggshu import aes, ggmap, geom_hist\n\n(\n    # notice the change in the aesthetics!\n    ggmap(df, aes(reaction=\"reactions\", y=\"kcat\"))\n    # plot kcats as the y-axis of the histograms\n    + geom_hist()\n)\n</code></pre> <p>But we have not plotted the flux! We can plot them as, for instance, a density on the left side of the reactions.</p> <pre><code>from ggshu import geom_kde\n\n(\n    ggmap(df, aes(reaction=\"reactions\", y=\"kcat\"))\n    + geom_hist()\n    # by default, side is \"right\"\n    + geom_kde(aes=aes(y=\"flux\"), side=\"left\")\n)\n</code></pre> <p>Notice how, instead of using (inheriting) the initial aesthetics, we are overwriting them for the <code>geom_kde</code> mapping. Still, to give an impression of the mean, we can plot the color and size of the arrows as the flux.</p> <pre><code>(\n    # notice the change in the aesthetics!\n    ggmap(df, aes(reaction=\"reactions\", y=\"kcat\", color=\"flux\"))\n    + geom_hist()\n    + geom_arrow()\n    + geom_kde(aes=aes(y=\"flux\"), side=\"left\")\n).to_json(\"flux_kcat_dist\")\n</code></pre> <p>Warning</p> <p>Distribution data (where one reaction/metabolite appears more than once in the column) will be coerced to the mean when used with a <code>geom_arrow</code> or a <code>geom_metabolite</code>.</p> <p>The generated file <code>flux_kcat_dist.metabolism.json</code> can be used like before at shu website.</p> <p></p> <p>Notice how, there is not enough data to generate a meaningful histogram.</p>"},{"location":"plotting/#histogram-position","title":"Histogram position","text":"<p>Shu tries to fit the best plotting position next to the arrows with an heuristic but it may fail for some reactions. </p> <p>Try pressing right or middle mouse button in the middle of a histogram to rotate or move it. If an x-axis of the side plots is too big or too small, press <code>s</code> and the x-axes will be displayed. In this mode, the behavior of right clicks is changed to now scale the axes.</p> <p>After moving, rotating and scaling the axes as desired, all these new coordinates can be saved to a new map in the settings window (only available for the desktop app) for futures shu sessions.</p> <p>An SVG image of the map can also be exported through the settings window (for all platforms and the web). PNG/JPEG/BMP/TGA are also supported if the provided paths have one of their corresponding extensions.</p>"},{"location":"plotting/#hover","title":"Hover","text":"<p>Instead of plotting a distribution on the right or the left side we can put the plot on a popup that appears when hovering over the name of the reaction or a metabolite.</p> <p>Try the example from before but change the side in the kde or in the histogram. For instance:</p> <pre><code>    + geom_hist(side=\"hover\")\n</code></pre>"},{"location":"plotting/#plotting-metabolites-and-conditions","title":"Plotting metabolites and conditions","text":"<p>So far we have been plotting only reactions, but the nodes on the map (i.e., metabolites) can be used to map the data too! For instance:</p> <pre><code>(\n    ggmap(\n        df_cond,\n        aes(reaction=\"r\", color=\"flux\", size=\"flux\", condition=\"cond\", y=\"kcat\"),\n    )\n    # plot flux to color and size of reactions\n    + geom_arrow()\n    # plot kcat as histogram shows on left side of reactions\n    + geom_hist(side=\"left\")\n    # plot conc to color of metabolites\n    + geom_metabolite(aes=aes(color=\"conc\", metabolite=\"m\"))\n    # plot km as density plots shows on hover on metabolites\n    + geom_kde(aes=aes(y=\"km\"), mets=True)\n).to_json(\"shu_data\")\n</code></pre> <p>Notice that now we have specified a new aesthetics: <code>condition</code>. Shu will show a dropdown in settings to plot this kind of data.</p>"},{"location":"plotting/#using-two-dataframes","title":"Using two dataframes","text":"<p>In the previous section, we used a dataframe called <code>df_cond</code>. To make it work like that, <code>df_cond.conditions</code> has to be aligned with both reactions and metabolites. Usually, this is not easy, so ggshu provides a way to generate the reaction mapping and metabolite mapping separetely and then merge it by using the division <code>/</code> operator.</p> <pre><code>reaction_map = (\n    ggmap(\n        df_reactions,\n        aes(reaction=\"r\", color=\"flux\", size=\"flux\", condition=\"cond\", y=\"kcat\"),\n    )\n    # plot flux to color and size of reactions\n    + geom_arrow()\n    # plot kcat as histogram shows on left side of reactions\n    + geom_hist(side=\"left\"))\n)\nmetabolite_map = (ggmap(\n        df_metabolites,\n        aes(metabolite=\"m\", color=\"conc\", y=\"km\", condition=\"cond\"),\n    )\n    # plot conc to color of metabolites\n    + geom_metabolite(aes=aes(color=\"conc\", metabolite=\"m\"))\n    # plot km as density plots shows on hover on metabolites\n    + geom_kde(aes=aes(y=\"km\"), mets=True))\n)\n(reaction_map / metabolite_map).to_json(\"shu_data\")\n</code></pre>"},{"location":"plotting/#point-estimates-on-the-sides","title":"Point estimates on the sides","text":"<p>Sometimes distributed data is not available but we have different variables that we want to plot into a reaction. We can use <code>geom_boxpoint()</code> to plot this kind of data (also works with conditions):</p> <pre><code>from ggshu import geom_boxpoint\n\n(\n   # this is the same dataframe as in the distribution example\n    ggmap(df, aes(reaction=\"reactions\", y=\"flux\", color=\"kcat\"))\n    + geom_kde(side=\"left\")\n    # instead of geom_arrow, use a boxpoint\n    + geom_boxpoint()\n).to_json(\"flux_kcat_dist\")\n</code></pre> <p></p>"},{"location":"plotting/#data-format","title":"Data Format","text":"<p>If <code>ggshu</code> is not enough, you can check the lower level data format that shu uses (the ouput that <code>ggshu</code> generates) in the file_formats section.</p>"}]}